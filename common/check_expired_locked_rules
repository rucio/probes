#!/usr/bin/env python3
# Copyright 2012-2024 CERN
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Authors:
# - Cedric Serfon, <cedric.serfon@cern.ch>, 2015
# - Donata Mielaikaite, <donata.mielaikaite@cern.ch>, 2020
# - Eric Vaandering, <ewv@fnal.gov>, 2020
# - Maggie Voetberg <maggiev@fnal.gov>, 2024


'''
Probe to check the locked expired rules or datasets with locked rules
'''

from collections import defaultdict
import datetime
import sys
import traceback
from sqlalchemy import select, and_
from sqlalchemy.sql import true, null

from rucio.db.sqla import models, session
from utils.common import PrometheusPusher

# Exit statuses
OK, WARNING, CRITICAL, UNKNOWN = 0, 1, 2, 3

if __name__ == '__main__':

    status = OK
    session = session.get_session()

    # Select statement used for both metrics
    base_statement = select(
        models.ReplicationRule,
        models.DataIdentifier.name,
        models.DataIdentifier.scope,
        models.ReplicationRule.rse_expression,
    )

    # Use prometheus pusher to send results to a remote service
    with PrometheusPusher() as manager:
        try:
            statement = base_statement.where(
                and_(
                    models.ReplicationRule.locked == true(),
                    models.ReplicationRule.expires_at < datetime.utcnow()  # see https://github.com/rucio/rucio/issues/6476
                )
            )
            rule_counts = defaultdict(int)

            # Print rules for nagios monitoring
            print("Locked expired rules")
            for row in session.execute(statement):
                print(row.rule_id, row.scope, row.name, row.rse_expression)
                status = CRITICAL
                # Keep track of the counts
                rule_counts[row.rse_expression] += 1

            # Add a summary entry so when there are no result from the query there is metric continuity
            rule_counts["All"] = sum(rule_counts.values())

            # Send to Prometheus pusher
            for rse_expression, count in rule_counts.items():
                (manager.gauge(
                        "locked_expired_rules.{rse_expression}",
                        documentation="Number of rules that are locked and expired, by RSE expression.")
                    .labels(rse_expression=rse_expression)
                    .set(count))

        except Exception as error:
            print(traceback.format_exc())
            sys.exit(UNKNOWN)

        try:
            statement = base_statement.join(
                models.DataIdentifier,
                and_(
                    models.ReplicationRule.scope == models.DataIdentifier.scope,
                    models.ReplicationRule.name == models.DataIdentifier.name,
                ),
            ).where(
                and_(
                    models.ReplicationRule.locked == true(),
                    models.DataIdentifier.expired_at != null(),
                    models.DataIdentifier.expired_at < datetime.utcnow()  # see https://github.com/rucio/rucio/issues/6476
                )
            )
            datasets_count = defaultdict(int)

            print("Datasets expired with locked rules")
            for row in session.execute(statement):
                print(row.rule_id, row.scope, row.name, row.rse_expression)
                status = CRITICAL
                datasets_count[row.rse_expression] += 1

            rule_counts["All"] = sum(rule_counts.values())
            for rse_expression, dids in datasets_count.items():
                (manager.gauge(
                        "locked_expired_rules.dids.{rse_expression}",
                        documentation="Number of expired DIDs with locked rules, by RSE expression")
                    .labels(rse_expression=rse_expression)
                    .set(dids))

        except:
            print(traceback.format_exc())
            sys.exit(UNKNOWN)

    sys.exit(status)
